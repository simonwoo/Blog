<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>吴冲的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="吴冲的博客">
<meta property="og:url" content="http://simonwoo.github.io/blog/index.html">
<meta property="og:site_name" content="吴冲的博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="吴冲的博客">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="吴冲的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/blog//favicon.png">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/blog/img/wuchong.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">吴冲</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>

				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/archives">主页</a></li>
				        
							<li><a href="/blog/tags/javascript">前端</a></li>
				        
							<li><a href="/blog/tags/Java">Java</a></li>
				        
							<li><a href="/blog/tags/Linux">Linux</a></li>
				        
							<li><a href="/blog/tags/其他">其他</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/simonwoo" title="github">github</a>
					        
								<a class="linkedin" target="_blank" href="http://simonwoo.github.io/cv" title="linkedin">linkedin</a>
					        
						</div>
					</nav>
				</section>

				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/DI/" style="font-size: 15px;">DI</a> <a href="/blog/tags/Guice/" style="font-size: 10px;">Guice</a> <a href="/blog/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/blog/tags/Java/" style="font-size: 20px;">Java</a> <a href="/blog/tags/Java8/" style="font-size: 15px;">Java8</a> <a href="/blog/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/blog/tags/Oauth2/" style="font-size: 10px;">Oauth2</a>
					</div>
				</section>
				

				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">Full-stack web developer</div>
				</section>
				
			</div>
		</div>
	</header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">吴冲</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/blog/img/wuchong.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">吴冲</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/archives">主页</a></li>
		        
					<li><a href="/blog/tags/javascript">前端</a></li>
		        
					<li><a href="/blog/tags/Java">Java</a></li>
		        
					<li><a href="/blog/tags/Linux">Linux</a></li>
		        
					<li><a href="/blog/tags/其他">其他</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/simonwoo" title="github">github</a>
			        
						<a class="linkedin" target="_blank" href="http://simonwoo.github.io/cv" title="linkedin">linkedin</a>
			        
				</div>
			</nav>
		</header>
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-Oauth2流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/02/01/Oauth2流程/" class="article-date">
  	<time datetime="2016-01-31T23:00:00.000Z" itemprop="datePublished">2016-02-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/02/01/Oauth2流程/">Oauth2认证</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>使使用者不需要把自己的帳號密碼給予第三方服務也可以使用服務提供者的API。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>我想将储存在google driver上的照片使用一家网络冲洗照片公司 - 云照片冲洗出来。但是云照片没有访问我的google driver的权利。<br>为了使它能够访问，我必须对其进行授权。如何获取授权？最简单的方式就是告诉云冲洗我的google账户和密码，但是这种方式会有潜在的风险。<br>OAuth2就是为了解决授权问题而生。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>在OAuth2中有几个概念：</p>
<ul>
<li>Third-party application：第三方应用程序，又称”客户端”（client），即云照片。</li>
<li>HTTP service：HTTP服务提供商，本文中简称”服务提供商”，即上一节例子中的Google。</li>
<li>Resource Owner：资源所有者，本文中又称”用户”（user）。</li>
<li>User Agent：用户代理，本文中就是指浏览器。</li>
<li>Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。</li>
<li>Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。</li>
</ul>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorizationlayer）。<br>“客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。<br>“客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。<br>“客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p><img src="http://7xq5i5.com1.z0.glb.clouddn.com/img_OAuth2.png" alt="process" title="OAuth2授权流程"></p>
<ul>
<li>用户打开客户端以后，客户端要求用户给予授权。</li>
<li>用户同意给予客户端授权。</li>
<li>客户端使用上一步获得的授权，向认证服务器申请令牌。</li>
<li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</li>
<li>客户端使用令牌，向资源服务器申请获取资源。</li>
<li>资源服务器确认令牌无误，同意向客户端开放资源。</li>
</ul>
<p>第二步是最关键的一步，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。</p>
<h2 id="客户端的授权模式"><a href="#客户端的授权模式" class="headerlink" title="客户端的授权模式"></a>客户端的授权模式</h2><p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0定义了四种授权方式。</p>
<ul>
<li>授权码模式（authorization code）</li>
<li>简化模式（implicit）</li>
<li>密码模式（resource owner password credentials）</li>
<li>客户端模式（client credentials）</li>
</ul>
<h3 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h3><p><img src="http://7xq5i5.com1.z0.glb.clouddn.com/img_Authorization_code.png" alt="process" title="授权码模式"></p>
<p>步骤如下：</p>
<ul>
<li>用户访问客户端，后者将前者导向认证服务器。</li>
<li>用户选择是否给予客户端授权。</li>
<li>假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</li>
<li>客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</li>
<li>认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</li>
</ul>
<p>参数如下：</p>
<p>步骤1中，客户端申请认证的URI，包含以下参数：</p>
<ul>
<li>response_type：表示授权类型，必选项，此处的值固定为”code”</li>
<li>client_id：表示客户端的ID，必选项</li>
<li>redirect_uri：表示重定向URI，可选项</li>
<li>scope：表示申请的权限范围，可选项</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>下面是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET https://github.com/login/oauth/authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure></p>
<p>步骤3中，服务器回应客户端的URI，包含以下参数：</p>
<ul>
<li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li>
<li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li>
</ul>
<p>下面是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://callbackUrl?code=SplxlOBeZQQYbYS6WxSbIA&amp;state=xyz</span><br></pre></td></tr></table></figure></p>
<p>步骤4中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li>
<li>code：表示上一步获得的授权码，必选项。</li>
<li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li>
<li>client_id：表示客户端ID，必选项。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST https://github.com/login/oauth/access_token?grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span><br></pre></td></tr></table></figure>
<p>步骤5中，认证服务器发送的HTTP回复，包含以下参数：</p>
<ul>
<li>access_token：表示访问令牌，必选项。</li>
<li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li>
<li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li>
<li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li>
<li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li>
</ul>
<p>下面是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/json</span><br><span class="line">&#123;&quot;access_token&quot;:&quot;e72e16c7e42f292c6912e7710c838347ae178b4a&quot;, &quot;scope&quot;:&quot;repo,gist&quot;, &quot;token_type&quot;:&quot;bearer&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面代码可以看到，相关参数使用JSON格式发送（Content-Type: application/json）。此外，HTTP头信息中明确指定不得缓存。<br>授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动。对于其他模式，不在这里一一叙述。<br>如果大家感兴趣可以参考github的Oauth2授权流程：<a href="https://developer.github.com/v3/oauth/。" target="_blank" rel="external">https://developer.github.com/v3/oauth/。</a></p>
<h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>如果用户访问的时候，客户端的”访问令牌”已经过期，则需要使用”更新令牌”申请一个新的访问令牌。<br>客户端发出更新令牌的HTTP请求，包含以下参数：</p>
<ul>
<li>granttype：表示使用的授权模式，此处的值固定为”refreshtoken”，必选项。</li>
<li>refresh_token：表示早前收到的更新令牌，必选项。</li>
<li>scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Oauth2/">Oauth2</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pushd和popd快速定位" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/01/31/pushd和popd快速定位/" class="article-date">
  	<time datetime="2016-01-30T23:00:00.000Z" itemprop="datePublished">2016-01-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/31/pushd和popd快速定位/">pushd和popd快速定位</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>pushd和popd可以用来在多个目录之间进行切换而无需复制粘贴目录路径。它们是以栈的方式来运行。<br>使用pushd和popd就可以无视cd了。<br>pushd压入路径并切换。<br>dirs查看路径栈。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-awk,sed,grep,find使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/01/30/awk,sed,grep,find使用/" class="article-date">
  	<time datetime="2016-01-29T23:00:00.000Z" itemprop="datePublished">2016-01-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/30/awk,sed,grep,find使用/">awk,sed,grep,find使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Awk, sed与Grep俗称Linux下三剑客。Sed是一种非交互式且面向字符流的编辑器（a non-interactive stream editor）, awk是一门模式匹配的编程语言，它主要用于匹配文本并处理，同时它也有一些编程语言才有的语法，如函数，分支循环语句，变量等。</p>
<h2 id="awk使用"><a href="#awk使用" class="headerlink" title="awk使用"></a>awk使用</h2><p>awk语法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk [-F ERE] [-v assignment] ... program [argument ...]</span><br><span class="line">awk [-F ERE] <span class="_">-f</span> progfile ... [-v assignment] ...[argument ...]</span><br></pre></td></tr></table></figure>
<p>program一般由多个pattern和action组成，当读入的记录匹配pattern时，才会执行相应的action。awk的输入被解析成多条record，默认情况下，记录分隔符是\n, 可以通过内置变量RS更改。因此可以认为一行是一条记录。每个记录被分割成多个Field，默认情况下字段的分隔符是空白符，例如空格，制表符等等，可以通过-F ERE选项改变或者通过内置变量FS更改。在awk中可以通过$1,$2…来访问对应位置的字段，同时$0存放着整个记录。</p>
<p>标准awk命令参数有三个：</p>
<ul>
<li>-F ERE : 定义字段分隔符，该选项的值可以是扩展的正则表达式（ERE）</li>
<li>-f progfile : 指定awk脚本，可以同时指定多个脚本，他们会按照在命令行出现的顺序连接在一起。</li>
<li>-v assignment : 定义awk变量，name = value, 赋值发生在awk处理文本之前。</li>
</ul>
<h2 id="sed使用"><a href="#sed使用" class="headerlink" title="sed使用"></a>sed使用</h2><p>sed语法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [option] commands [file-to-edit]</span><br></pre></td></tr></table></figure>
<p>sed执行流程：</p>
<p><img src="http://7xq5i5.com1.z0.glb.clouddn.com/img_sed.png" alt="sed"></p>
<h2 id="grep使用"><a href="#grep使用" class="headerlink" title="grep使用"></a>grep使用</h2><p>grep是一种强大的文本搜索工具，它使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<p>语法：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [options] pattern [files]</span><br></pre></td></tr></table></figure></p>
<p>例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"this is a word\nnext line"</span> | grep word --color=auto</span><br><span class="line"><span class="comment">#正则表达式</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"this is a word\nnext line."</span> | grep -E <span class="string">"[a-z]*\."</span></span><br><span class="line"><span class="comment"># 统计个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="_">-e</span> <span class="string">"1,2,3,4,5\n6,7"</span> | grep -E -o <span class="string">"[0-9]"</span> | wc <span class="_">-l</span></span><br><span class="line"><span class="comment"># 在该目录下递归搜索并忽略大小写</span></span><br><span class="line">grep <span class="string">"text"</span> . -R -n -i</span><br></pre></td></tr></table></figure>
<h2 id="find使用"><a href="#find使用" class="headerlink" title="find使用"></a>find使用</h2><p>find是一个非常有效的工具，它可以遍历当前目录甚至整个文件系统来查找某些文件或者目录。</p>
<p>语法：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find pathname -options [-print -exec -ok]</span><br></pre></td></tr></table></figure>
<h2 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 文件名: word_freq.sh</span></span><br><span class="line"><span class="comment"># 用途: 计算单词的频率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>[ <span class="variable">$#</span> <span class="_">-ne</span> 1 ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Usage: <span class="variable">$0</span> filename"</span>;</span><br><span class="line"><span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">filename=<span class="variable">$1</span></span><br><span class="line"><span class="comment">#\b是单词分界符</span></span><br><span class="line">grep -E -o <span class="string">"\b[[:alpha:]]+\b"</span> <span class="variable">$filename</span> | \</span><br><span class="line">awk <span class="string">'&#123; count[$0]++ &#125;</span><br><span class="line">END &#123;printf("%-14s%s\n", "Word","Count");</span><br><span class="line">for(ind in count)</span><br><span class="line">&#123;printf("%-14s%s\n",ind,count[ind]); &#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Linux/">Linux</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Hamcrest使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/01/10/Hamcrest使用/" class="article-date">
  	<time datetime="2016-01-09T23:00:00.000Z" itemprop="datePublished">2016-01-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/10/Hamcrest使用/">Hamcrest使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Hamcrest是一个开源的库，07年被引入到Junit4。<code>assertThat()</code>是其中最常用的一个方法，位于org.junit.Assert包中, 方法签名如下:<code>static &lt;T&gt; void assertThat(T actual, org.hamcrest.Matcher&lt;T&gt; matcher)</code>。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edgibbs.junit.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hamcrest.Description;</span><br><span class="line"><span class="keyword">import</span> org.hamcrest.Matcher;</span><br><span class="line"><span class="keyword">import</span> org.hamcrest.StringDescription;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HamcrestExamples</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allOfExampleShowsAllMatchersMustAllBeTrue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(allOf(notNullValue(), instanceOf(String.class), equalTo(<span class="string">"Hello"</span>))));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allOfExampleShowsFailingIfOneMatcherDoesNotMatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(not(allOf(notNullValue(), instanceOf(Integer.class)))));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyExampleChecksThatClassIsOfSameType</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(any(String.class)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyExampleShowsStringIsAlsoAnObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(any(Object.class)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyOfExampleReturnsTrueIfOneMatches</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(anyOf(nullValue(), instanceOf(String.class), equalTo(<span class="string">"Goodbye"</span>))));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyOfExampleFailingIfAllMatchersAreFalse</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(not(anyOf(nullValue(), instanceOf(Integer.class), equalTo(<span class="string">"Goodbye"</span>)))));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anythingExampleAlwaysReturnsTrue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(anything()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Feels very esoteric and not for typical usage used to override the description</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describedAsExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Matcher&lt; ?&gt; matcher = describedAs(<span class="string">"My Description"</span>, anything());</span><br><span class="line">    Description description = <span class="keyword">new</span> StringDescription().appendDescriptionOf(matcher);</span><br><span class="line">    assertThat(<span class="string">"My Description"</span>, is(description.toString()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">equalToExampleAddingTwoPlusTwo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="number">2</span> + <span class="number">2</span>, is(equalTo(<span class="number">4</span>)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceOfExampleForString</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(instanceOf(String.class)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isExampleShortCutForIsInstanceOfClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(String.class));</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, instanceOf(String.class));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isExampleShortCutAsJustSyntacticSugarUsedThreeTimes</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(is(is(notNullValue()))));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isExampleShortCutForIsEqualTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(<span class="string">"Hello"</span>));</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, equalTo(<span class="string">"Hello"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notExampleJustInvertsExpression</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(not(instanceOf(Integer.class))));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notNullValueExampleForString</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(notNullValue()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notNullValueExampleForAClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="string">"Hello"</span>, is(notNullValue(Object.class)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nullValueExampleWithANull</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    assertThat(<span class="keyword">null</span>, is(nullValue()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nullValueExampleWithANullType</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Integer nothing = <span class="keyword">null</span>;</span><br><span class="line">    assertThat(nothing, is(nullValue(Integer.class)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sameInstanceExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object object = <span class="keyword">new</span> Object();</span><br><span class="line">    Object sameObject = object;</span><br><span class="line">    assertThat(object, is(sameInstance(sameObject)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java8/">Java8</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java8之optional使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/01/07/java8之optional使用/" class="article-date">
  	<time datetime="2016-01-06T23:00:00.000Z" itemprop="datePublished">2016-01-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/07/java8之optional使用/">Java8之Optional使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------------------------</span><br><span class="line">|       computer       |</span><br><span class="line">| -------------------- |</span><br><span class="line">| |     soundcard    | |</span><br><span class="line">| | ---------------- | |</span><br><span class="line">| | |     USB      | | |</span><br><span class="line">| | | ------------ | | |</span><br><span class="line">| | | | version  | | | |</span><br><span class="line">| | | ------------ | | |</span><br><span class="line">| | ---------------- | |</span><br><span class="line">| -------------------- |</span><br><span class="line">------------------------</span><br></pre></td></tr></table></figure>
<p>让我们以电脑的结构为例，说明Optional的使用。电脑通常情况下包含声卡，声卡里包含USB，每个USB有对应的版本号。<br>如果想获得声卡中USB的版本号，我们通常使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String version = computer.getSoundcard().getUSB().getVersion();</span><br></pre></td></tr></table></figure>
<p>这段代码有潜在的风险。某些情况下，电脑也不一定具备声卡，如Raspberry Pi(树莓派)。所以<code>getSoundcard()</code>有可能返回一个null值。<code>getUSB()</code>则返回一个null值得USB，这会导致运行期抛出NullPointerException。为了阻止这种情况的发生，我们经常会进行null值检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String version = UNKNOWN;</span><br><span class="line"><span class="keyword">if</span>(computer != <span class="keyword">null</span>)&#123;</span><br><span class="line">  Soundcard soundcard = computer.getSoundcard();</span><br><span class="line">  <span class="keyword">if</span>(soundcard != <span class="keyword">null</span>)&#123;</span><br><span class="line">    USB usb = soundcard.getUSB();</span><br><span class="line">    <span class="keyword">if</span>(usb != <span class="keyword">null</span>)&#123;</span><br><span class="line">      version = usb.getVersion();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于多重嵌套进行null坚持，这段代码非常丑陋。让我们看看Optional是怎么完成相同的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String version = computer.flatMap(Computer::getSoundcard)</span><br><span class="line">                          .flatMap(Soundcard::getUSB)</span><br><span class="line">                          .map(USB::getVersion)</span><br><span class="line">                          .orElse(<span class="string">"UNKNOWN"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Optional使用"><a href="#Optional使用" class="headerlink" title="Optional使用"></a>Optional使用</h2><h3 id="创建Optional对象"><a href="#创建Optional对象" class="headerlink" title="创建Optional对象"></a>创建Optional对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Soundcard&gt; sc = Optional.empty(); <span class="comment">//an empty Optional object</span></span><br><span class="line"></span><br><span class="line">SoundCard soundcard = <span class="keyword">new</span> Soundcard();</span><br><span class="line">Optional&lt;Soundcard&gt; sc = Optional.of(soundcard); <span class="comment">//an non-null Optional object</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Soundcard&gt; sc = Optional.ofNullable(soundcard); <span class="comment">// an Optional object that may hold a null value</span></span><br></pre></td></tr></table></figure>
<h3 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Soundcard&gt; soundcard = ...;</span><br><span class="line">soundcard.ifPresent(System.out::println);</span><br><span class="line"></span><br><span class="line">Soundcard soundcard = maybeSoundcard.orElse(<span class="keyword">new</span> Soundcard(<span class="string">"defaut"</span>));</span><br><span class="line"></span><br><span class="line">Soundcard soundcard = maybeSoundCard.orElseThrow(IllegalStateException::<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* The filter method takes a predicate as an argument.</span><br><span class="line">* If a value is present in the Optional object and it matches the predicate, the filter method returns that value;</span><br><span class="line">* otherwise, it returns an empty Optional object.</span><br><span class="line">**/</span></span><br><span class="line">Optional&lt;USB&gt; maybeUSB = ...;</span><br><span class="line">maybeUSB.filter(usb -&gt; <span class="string">"3.0"</span>.equals(usb.getVersion())</span><br><span class="line">                    .ifPresent(() -&gt; System.out.println(<span class="string">"ok"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// extracting and transforming values using map, nothing happens if Optional object is empty                  </span></span><br><span class="line">Optional&lt;USB&gt; usb = maybeSoundcard.map(Soundcard::getUSB);      </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Optional also supports a flatMap method.</span><br><span class="line">* Its purpose is to apply the transformation function on the value of an Optional (just like the map operation does) and then flatten the * resulting two-level Optional into a single one</span><br><span class="line">**/</span></span><br><span class="line">String version = computer.flatMap(Computer::getSoundcard)</span><br><span class="line">                   .flatMap(Soundcard::getUSB)</span><br><span class="line">                   .map(USB::getVersion)</span><br><span class="line">                   .orElse(<span class="string">"UNKNOWN"</span>);</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java8/">Java8</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Java内存区域与内存溢出异常" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/01/04/Java内存区域与内存溢出异常/" class="article-date">
  	<time datetime="2016-01-03T23:00:00.000Z" itemprop="datePublished">2016-01-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/04/Java内存区域与内存溢出异常/">Java内存区域与内存溢出异常</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中，会把内存分为不同的数据区域。如下图所示：</p>
<p><img src="http://7xq5i5.com1.z0.glb.clouddn.com/img_jvm_model.png" alt="内存分布"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>它是一块较小的内存空间，作用可以当做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一跳需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器（字节码行号记录器）。</p>
<p>因为java虚拟机的多线程是通过时间片轮转占用cpu，所以一个处理器只会执行一条线程的指令。为了线程切换后能恢复到正确的位置，每个线程都需要一个独立的程序计数器，这样能使各个线程之间的计数器互不影响，独立存储。这类区域为线程私有内存。</p>
<ul>
<li>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令地址</li>
<li>如果线程正在执行的是 Native 方法，这个计数器值为空（Undefined）</li>
</ul>
<p>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈也是线程私有的，它的生命周期和线程相同。</p>
<p>Java虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。调用一个方法时创建新的栈帧并压入栈顶部，方法执行完后，这个栈帧就会弹出栈帧的元素作为这个方法的返回值，并清除这个栈帧，Java栈的栈顶就是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向这个地址。</p>
<p>局部变量表存放了基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p>
<ul>
<li>如果线程请求的栈深度太深，超出了虚拟机所允许的深度，就会出现StackOverFlowError（比如无限递归。因为每一层栈帧都占用一定空间，而 Xss 规定了栈的最大空间，超出这个值就会报错）</li>
<li>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存空间，会出现OOM</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈的作用是非常类似的，区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。因为虚拟机规范没有对这块有太多规定，所以不同的虚拟机可以自由实现它。有的虚拟机（Sun的HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一了。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的，在虚拟机启动时候创建。Java堆唯一的目的就是存放对象实例（当然还有数组），Java堆是垃圾收集器管理的主要区域。堆可分为老年代和新生代，再细分还可以分为Eden空间、From Survivor空间、To Survivor空间等。主流虚拟机都可扩展（-Xmx和-Xms）</p>
<p>如果堆上没有内存可以完成对象实例的分配，并且堆已经达到了最大容量，无法向OS继续申请的时候，就会抛出OOM异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与Java堆一样，是所有线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>对于习惯在 HotSpot虚拟机上开发部署程序的开发者来说，很多人倾向于把方法区成为“永久代（Perm Generation）”，但本质上两者并不等价，仅仅是因为 HotSpot 团队选择把 GC 分代收集扩展到方法区，或者说使用永久代来实现方法区而已，目的是为了让 HotSpot 的垃圾回收器可以像管理 Java 堆一样管理这部分内存，不能再编写这部分内存的内存管理代码。对于其他虚拟机（比如 JRockit、IMB J9）来说，是不存在永久代的概念的。</p>
<p>其实 JVM 规范并没有规定如何实现方法区，但是从目前状况来看：使用永久代来实现方法区不是一个好的做法。因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize 的上限，而 J9和 Jrockit 只要没有触碰到进程可用内存的上限，例如32位的4GB，就不会出现问题），同时有极少数方法（比如 String.intern()，这个函数能直接操纵方法区中的常量池）会因为这个原因在不同虚拟机有不同的表现。因此，HotSpot 团队有了放弃永久代并逐步改为采用 Native Memory 来实现方法区的规划，在目前已经发布的 JDK1.7 的 HotSpot 中，已经把放在永久代的字符串常量池移出。</p>
<p>当方法区无法满足分寸分配需求时，就会抛出OOM异常。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>方法区的一部分。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(class文件中)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于class文件常量池的另外一个重要特性是具备动态性，Java语言并不要求常量一定是在编译期产生，也就是说，并非是预置入class文件中常量池的内容内能进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，用的比较多是有String.intern()，可以去看下文档。说的很清楚：</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>JDK 1.4中新加入了NIO(NEW Input/Output)类，引入了一种基于通道与缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OOM。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>程序计数器：行号指示器；空间小，最快；线程私有；不会有OOM</li>
<li>Java虚拟机栈：Java方法执行的内存模型,用于存储局部变量表、操作栈、动态链接、方法出口等信息；线程私有；StackOverFlowError,OOM</li>
<li>本地方法栈：和Java虚拟机栈发挥的作用非常相似，但是市委Native方法服务。</li>
<li>Java堆：存放对象实例；线程共享；OOM</li>
<li>方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；线程共享；OOM</li>
<li>运行时常量池：方法区的一部分；线程共享；存放编译期生成的各种字面量和符号引用；OOM</li>
<li>直接内存：直接内存并不是虚拟机运行时数据区的一部分，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现；新NIO利用了直接内存，效率高</li>
</ol>
<h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p>探讨Java堆中对象分配、布局和访问的全过程。</p>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><ol>
<li>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就得执行类的加载过程，这个过程在第七章讲了。TODO 添加第七章链接</li>
<li><p>类加载检查过之后，虚拟机就为这个新生对象分配内存。目前有两种做法，使用哪种方式是由 GC 回收器是否带有压缩整理功能决定的：</p>
<ul>
<li>指针碰撞（Bump the Pointer）：假设Java堆中内存是绝对规整的 ，没用过的内存和用过的内存用一个指针划分（需要保证 java 堆中的内存是规整的，一般情况是使用的 GC 回收器有压缩整理功能），分配内存仅仅是将指针向空闲空间那边挪动一段与对象大小相等的距离。假如需要分配8个字节，指针就往后挪8个字节</li>
<li>空闲列表（Free List）：假设Java堆中内存是不规整的，已使用内存和空闲内存交错，虚拟机维护一个列表，记录哪些内存是可用的，分配的时候从列表中遍历，找到合适的内存分配，然后更新列表</li>
</ul>
</li>
<li><p>分配内存过程中还需要解决线程安全问题。 就刚才的一个修改指针操作，就会带来隐患：对象 A 正分配内存呢，突然对象 B 又同时使用了原来的指针来分配 B 的内存。解决方案也有两种：</p>
<ul>
<li>同步处理——实际上虚拟机采用 CAS 配上失败重试来保证更新操作的原子性</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，成为本地线程分配缓存（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，用完并分配新的TLAB时，才需要同步锁定（虚拟机是否使用 TLAB，可以通过-XX:+/-UseTLAB 参数来设置）</li>
</ul>
</li>
<li><p>给内存分配了空间之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p>
</li>
<li><p>接下来要对对象进行必要的设置，比如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的 hashcode 值是多少、对象的 GC 分代年龄等信息，这些信息都放在对象头中。</p>
</li>
<li><p>上面的步骤都完成后，从虚拟机角度来看，一个新的对象已经产生了，但是从 Java 程序的视角来看，对象创建才刚刚开始——<init> 方法还没有执行，所有的字段都还为零。把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</init></p>
</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>首先我们要知道的是：在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instantce Data）、对齐补充（Padding）。</p>
<ol>
<li>对象头（Header）：包含两部分信息。第一部分用于存储对象自身的运行时数据，如 hashcode 值、GC 分代的年龄、锁状态标志、线程持有的锁等，官方称为“Mark Word”。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>实例数据（Instance Data）：就是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li>
<li>内存对齐，对象的大小必须是8字节的整数倍</li>
</ol>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><ol>
<li>假如代码出现在方法体中，那么Object obj就会存在在Java虚拟机栈的本地变量表中，作为一个引用类型数据。</li>
<li>new Object()则存在在Java堆上。另外，在Java堆上还必须包含能查找到该对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。</li>
<li><p>由于引用类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式可能不同，主流的有：</p>
<ul>
<li>使用句柄：Java堆中划分一块区域作为句柄池，引用存储的是对象的句柄地址，而句柄中含有对象实例数据和类型数据各自的数据信息</li>
<li>直接指针：引用中直接存储的就是对象的地址，同时还必须包括方法区类型信息的指针<br>下面是对应的图片：<br><img src="http://7xq5i5.com1.z0.glb.clouddn.com/img_reference_handler.jpg" alt="reference handler"></li>
</ul>
</li>
</ol>
<p><img src="http://7xq5i5.com1.z0.glb.clouddn.com/img_direct_reference.jpg" alt="direct reference"></p>
<p>对于引用类型的实现，不同的实现方法有不同的特点：</p>
<ol>
<li>使用句柄：Java堆会划出一块区域作为句柄池，引用中存储的是稳定的句柄地址，而句柄中包含了对象实例数据（也在Java堆）和类型数据（方法区中）各自的地址信息。在对象被移动（垃圾回收时移动对象是非常普遍的行为）时只需要改变句柄中的实例数据指针，而引用本身核方法区的类型数据指针都不需要修改</li>
<li>直接指针：速度更快，因为不需要间接寻址。对于效率而言是更好的，Sun HotSpot就是使用这种方式实现对象访问的。但在其他虚拟机中，使用句柄方式也非常常见。</li>
</ol>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>下面我们会演示几个小程序，目的有两个：</p>
<ol>
<li>通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容</li>
<li>希望以后遇到类似问题时，能根据异常的信息快速判断是哪个区域的内存溢出，知道怎样的代码可能会导致这些区域的内存溢出，以及出现这些异常后改如何处理</li>
</ol>
<h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>这个顾名思义，是最常见的。因为Java堆上存储的是对象实例，所以只要保证GC roots到该对象有路径可达，就会在不断创建对象的过程中达到Java堆的最大容量而导致溢出。下面是实例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看到，发生了OOM异常。要解决这个异常，一般是把内存快照dump（通过-XX:+HeapDumpOnOutOfMemoryError）下来用工具（Eclipse Memmory Analyzer）分析，确认内存中的对象是否是必要的，也就是要先分清到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory overflow）。</p>
<ul>
<li>如果是内存泄露：使用工具查看泄露对象到GC Roots的引用链。于是就可以顺藤摸瓜找到泄漏对象是通过怎样的路径关联GC Roots的，从而准确定位泄露代码的位置</li>
<li>如果是内存溢出：就应当检查虚拟机的堆参数（-Xmx和-Xms），与机器物理内存对比看是否可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长等情况，尝试减少程序运行期间的内存消耗</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><p>-Xss可以设置栈容量。</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常<br>通过调用无限递归调用，单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError。通过不断创建线程倒是可以产生内存溢出异常，不过和栈空间是否足够大并不存在任何联系。</li>
</ul>
<h3 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</span><br><span class="line">        String str1=<span class="keyword">new</span> StringBuilder（<span class="string">"计算机"</span>）.append（<span class="string">"软件"</span>）.toString（）；</span><br><span class="line">        System.out.println（str1.intern（）==str1）；</span><br><span class="line">        String str2=<span class="keyword">new</span> StringBuilder（<span class="string">"ja"</span>）.append（<span class="string">"va"</span>）.toString（）；</span><br><span class="line">        System.out.println（str2.intern（）==str2）；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。产生差异的原因是：在JDK 1.6中，intern（）方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。而JDK 1.7（以及部分其他虚拟机，例如JRockit）的intern（）实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern（）返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString（）之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</p>
<p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/">Java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-垃圾收集器与内存分配" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/01/04/垃圾收集器与内存分配/" class="article-date">
  	<time datetime="2016-01-03T23:00:00.000Z" itemprop="datePublished">2016-01-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/04/垃圾收集器与内存分配/">垃圾收集器与内存分配</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序计数器、虚拟机栈、本地方法栈这些区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。垃圾收集器关注的是堆和方法区中的垃圾。</p>
<h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>这种计数法无法解决循环引用的问题</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<p>虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>方法区中类静态属性引用的对象。<br>方法区中常量引用的对象。<br>本地方法栈中JNI（即一般说的Native方法）引用的对象</p>
<h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>在Java1.2之前，引用的定义是这样的：</p>
<p><code>如果reference类型的数据中存储的数值代表的是另外一块内存中的起始地址，就称这块内存代表着一个引用。</code></p>
<p>我们可以看到，这个引用的定义是非常狭隘的，和指针类似，只有引用、非引用区分。所以，在JAVA1.2以后提出了新的引用定义：</p>
<ul>
<li>强引用：在代码中普遍存在的，类似Object obj = new Object();。只要强引用还存在，垃圾回收期就永远不会回收被引用的对象</li>
<li>软引用：用来描述一些还有用，但并非必须的对象。这样当系统要发生内存溢出异常之前，就会把软引用列进第二次垃圾回收的计划中。SoftReference</li>
<li>弱引用：比软引用还弱的引用，被弱引用的对象只能存活到下一次垃圾回收之前。WeakReference</li>
<li>虚引用：最弱的一种引用关系了。使用虚引用的唯一目的就是在这个对象回收前收到一个系统回收通知。PhantomReference</li>
</ul>
<h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使是不可达对象，也并非是非死不可的，这时候它们暂时处于”缓刑“阶段，真正宣告一个对象死亡，至少要经过两次标记过程：</p>
<p>如果对象在进行根搜索后发现跟root不同根，就被标记一次，同时进行筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()已经被JVM调用过（说明一个对象的finalize()方法只能执行一次），JVM会将这两种情况视为“没有必要执行”。如果这个对象有必要执行finalize()方法，JVM就会把它放在F-Queue中，稍后JVM会触发一个低优先级的线程去执行。但是去执行并并不承诺会等待它运行结束，因为如果一个对象在finalize()方法中执行缓慢，甚至发生了死循环，就会导致F-Queue其他对象永久处于等待状态，更严重的话可能会拖垮整个内存回收系统。finalize()是对象逃脱死亡命运的最后一次机会，稍后GC将会对F-Queue进行第二次小规模的标记，如果在finalize()中将自己和root挂在一个根上（比如把自己赋值给某个类变量或者对象的成员变量），那么在这第二次标记将会被移除出“即将回收的集合”：如果对象还没有逃脱，那么就基本上真的被回收了。</p>
<p><img src="http://7xq5i5.com1.z0.glb.clouddn.com/img_gc_mark.png" alt="两次标记过程"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"haha, i'm still alive!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第二次拯救自己，但是却跪了。因为finalize只能执行一次呀，亲！！</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*output:</span><br><span class="line">finalize method executed!</span><br><span class="line">haha, i'm still alive!</span><br><span class="line">5555, i'm dead!</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>我们可以清楚的看到，第一次在finalize()中赋值给类变量，所以和root同根自救了一次，但是因为finalize()只会执行一次，所以第二次标记时，JVM发现已经调用这个对象的finalize()，就知道没必要再执行finalize了，然后就被回收了。</p>
<p>作者非常不推荐使用finalize()方法自救对象，因为这是Java刚诞生为了使C/C++程序员更容易接受它作的一个妥协。它的运行带价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它使用“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方法都可以做的更好、更及时，完全可以忘掉Java有finalize()。</p>
<h3 id="方法回收区"><a href="#方法回收区" class="headerlink" title="方法回收区"></a>方法回收区</h3><p>Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，主要是因为在方法区进行垃圾回收的“性价比”很低：在堆中，尤其是在新生代中，常规应用进行一次垃圾回收一般可以回收70%-95%的空间，而永久代的垃圾回收效率也远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：</p>
<ul>
<li>废弃常量：以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li>
<li><p>无用的类：判断一个类是无用的类，条件比废弃变量要苛刻的多，要同时满足下面3个条件才能算是“无用的类”：</p>
<ol>
<li>该类所有的实例都已经被回收，意思是堆上没有该对象的实例了</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法（因为通过反射，就一定要加载该类）</li>
</ol>
</li>
</ul>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul>
<li>标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。有两个问题：一是效率不高；而是会产生内存碎片，当需要大的连续内存空间时，即使碎片内存总和远大于需求，也会触将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。实现简单，运行高效，但是空间缩小为原来的一半了。现在的商业JVM采用这种算法来回收新生代，IBM经过调研发现，新生代的对象98%都是朝生夕死的，所有并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor还存活着的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，也就是每次新生代中可用内存空间为整个内存空间的9/10，只有10%的内存是用来浪费的。当然了，我们无法保证每次回收只有少于10%的对象存活，当存活对象大于10%，就会借用其他内存（这里指老年代）进行分配担保。分配担保就相当于现实生活中的担保。</li>
<li>标记-整理算法：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（老年代就是采用这个方法）</li>
<li>分代收集算法：当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法没有啥特别的，就是根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据每个代不同的特点采用最适当的回收算法。比如新生代存活对象少，就采用Eden– Survivor复制算法；老年代存活对象少，复制的话代价太大，就可以采用标记-整理算法。</li>
</ul>
<p>总结：<br>标记-清除：简单，效率低，有内存碎片<br>复制：新生代，实现简单，运行高效，空间利用率低<br>标记-整理：老年代</p>
<h2 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>可达性分析在逐个检查引用链和GC停顿（保证分析工作的一致性）上浪费时间较多。主流Java虚拟机使用的都是准确式GC，虚拟机应当有办法直接得知哪些地方存放着对象的引用。HotSpot是通过一个OopMap的数据结构来达到这个目的的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>HotSpot没有为每条指令都生成OopMap，那样占用空间太多，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<p>另一个问题是如何让所有线程都跑到最近的安全点停顿。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>如果线程没有在执行呢，比如线程处于Sleep状态或者Blocked状态，就需要安全区域解决了。安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p>
<p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="http://7xq5i5.com1.z0.glb.clouddn.com/img_hotspot_gc.jpg" alt="gc"></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本，历史最悠久。新生代的，单线程的，只会用一个CPU或一个线程工作，并且收集时，必须暂停所有的工作线程，直到收集结束。它依然是虚拟机运行在Client端的默认新生代收集器。简单而高效，因为它不需要考虑线程切换，只专注一次把收集工作搞定，而且在Client端，新生代的内存一般只有几十M或者一两百M的样子，完成一次收集工作完全可以控制在几十毫秒或者一百毫秒左右，不会有很大的停顿感。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>这个本质上就是Serial收集器的多线程版本。许多运行在Server模式下的虚拟机中首选的新生代收集器，其中还有一个与性能无关但很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作。（原因是Parallel Scavenge收集器和后面的G1收集器都没有使用传统的GC收集器代码框架，而是另外独立实现的，其余几种收集器则共用了框架代码）。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，当然也可以使用-XX:+UseParNewGC选项来显式指定使用</p>
<p>单CPU的话一般会考虑用Serial，多CPU的话一般考虑用ParNew，它默认开启的收集器线程数和CPU核数相同，当你想控制的时候，可以使用<code>-XX:ParallelGCThreads</code>参数来限制收集器的线程数。</p>
<p>然后提前解释一下并行和并发的概念，因为后面会有几个并发和并行的收集器：</p>
<ul>
<li>并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。所以，遇到 Parallel 关键字的话，都是并行。所以当它们工作的时候，用户线程是阻塞的。所以也是 stop the world</li>
<li>并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会根据时间片轮转交替进行），用户程序继续运行，而垃圾收集程序运行在另外一个CPU上。所以遇到 concurrent 关键字就是 GC 线程和用户线程在一段时间内交叉运行，不会将用户线程阻塞，不是 stop the world</li>
</ul>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge也是一个新生代收集器，它也是使用复制算法的收集器，同时也是并行的多线程收集器。它的目标是达到可控制的CPU吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾回收时间）。比如虚拟机运行了100分钟，垃圾回收使用了1分钟，那么吞吐量就是99%。</p>
<p>这就说说一下应用场景了。</p>
<ul>
<li>停顿时间（垃圾回收时间）： 停顿时间越短越适合于用户交互的程序，良好的响应速度能提升用户体验</li>
<li><p>高吞吐量： 可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务<br>为了这两个目的，Parallel Scavenge收集器提供了2个参数：</p>
</li>
<li><p>-XX:MaxGCPauseMillis:大于0的毫秒数，收集器将尽力保证内存回收时间不超过这个值。不过不要异想天开认为把这个值设的特别小，就能使系统垃圾收集速度更快，GC停顿时间缩短肯定是有代价的，它会牺牲吞吐量和新生代空间来实现。<br>-XX:GCTimeRatio:大于0小于100的整数.假如设为N，那么垃圾收集时间占总时间的比率就是1/(1+N),比如设置为19,占比就是1/(1+19)=5%，默认值是99，即1%。</p>
</li>
<li>-XX:+UseAdaptiveSizePolicy:这也是一个有用的参数，放在这里说一下。它是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小(-Xmn)、Eden、Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以一同最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节策略也是Parallel Scavenge收集器和ParNew收集器的一个重要区别</li>
</ul>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记-整理“算法。这个收集器的主要意义就是被Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用；另外一个就是CMS的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。是在JDK 1.6之后才提供的。前面说过，Parallel Scavenge收集器采用了独立的架构，无法和CMS配合使用。那么，在JDK 1.6以前，Parallel Scavenge只能和Serial Old配合使用。因为Serial Old是单线程的，所以在多CPU情况下无法发挥性能，所以根本实现不了高吞吐量的需求，直到JDK 1.6推出了Parallel Old之后，Parallel Scavenge收集器和Parallel Old搭配，才真正实现了对吞吐量优先的控制。所以，在注重吞吐量及CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old组合。</p>
<h3 id="CMS（Comcurrent-Mark-Sweep）收集器"><a href="#CMS（Comcurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Comcurrent Mark Sweep）收集器"></a>CMS（Comcurrent Mark Sweep）收集器</h3><p>CMS收集器是以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或者B/S系统上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，给用户最佳的用户体验。而CMS收集器就非常符合这类应用的需求</p>
<p>从名字上可以看出，”Mark Sweep“是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤：</p>
<ol>
<li>初始标记(stop the world):初始标记仅仅只是标记一下GC roots能直接关联到的对象，速度很快</li>
<li>并发标记:并发标记就是进行GC Roots Tracing的过程</li>
<li>重新标记(stop the world):重新标记则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变化的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍微长一些，但远比并发标记的时间短</li>
<li>并发清除:垃圾清除</li>
</ol>
<p>由于整个过程中，并发标记和并发清除时间最长，收集器线程可以和用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS收集器的优点在于并发收集、低停顿，但是也不是完美的，主要有3个显著的缺点：</p>
<ol>
<li>CMS收集器对CPU资源非常敏感。默认情况下，CMS的收集线程数=(CPU数目+3)/4，当CPU个数大于4的时候，CMS的收集线程不会超过整个CPU占用率的25%。但是在CPU个数比较小的情况下，CPU占用就会突然增大，这样对于初始标记和并发标记这样”Stop The World”的过程来说，用户就会明显感觉到停顿。虽然有了解决方法，但已经废除了，就不多说了。</li>
<li>CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，它需要预留一部分空间提供并发收集时的线程使用。在JDK1.5默认设置下，CMS收集器在老年代使用了68%的空间会被激活，这是一个偏保守的设置。如果在应用中，老年代增长不是太快，可以适当调高这个参数-XX:CMSInitiatingOccupancyFraction。要是CMS运行期间预留的内存无法满足程序的需要，就会出现”Concurrent Mode Failure”失败，这时候JVM会启动后备方案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，因为是单线程，停顿时间就会更长了。所以如果大量出现”Concurrent Mode Failure”，就可以将这个值调低</li>
<li>CMS是基于标记-清除算法实现的收集器，所以会产生内存碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦：老年代还有空间但是没有连续的足够大的空间，于是不得不触发一次Full GC。为了解决这个问题，有一个开关叫做-XX:+UseCMSCompactAtFullCollection，用于在Full GC时开启内存碎片的合并整理过程。当然，这个内存整理没法并发，只有”Stop The World”了。另外，虚拟机还设计了一个参数-XX:CMSFullGCsBeforeCompaction,用于指定在多少次不压缩的Full GC后，跟着来一次带压缩的。</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点。</p>
<p>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。<br>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。<br>空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<br>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
<p>G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
<p>总结：</p>
<p>Serial收集器：新生代；复制算法；单线程；GC区域名称(GCLogging)：DefNew；优点：简单高效，Client模式下的默认新生代收集器；缺点：进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”。</p>
<p>ParNew收集器：新生代；复制算法；多线程；GC区域名称(GCLogging)：ParNew；优点：Server模式下的虚拟机中首选的新生代收集器。除了Serial收集器外，目前只有它能与CMS收集器配合工作；缺点：在单CPU的环境中绝对不会有比Serial收集器更好的效果<br>Parallel Scavenge收集器：新生代；复制算法；多线程；GC区域名称(GCLogging)：PSYoungGen；优点：吞吐量优先。缺点：无法与CMS配合使用</p>
<p>Serial Old收集器：老年代；标记-整理算法（Mark-Compact）；单线程；<br>GC区域名称(GCLogging)：Tenured；优点：与Parallel Scavenge配合；作为CMS的后备方案。缺点：性能较低</p>
<p>Parallel Old收集器：老年代；标记-整理算法（Mark-Compact）；多线程；GC区域名称(GCLogging)：ParOldGen；优点：与Parallel Scavenge配合，真正成为吞吐量优先的收集器组合。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<p>CMS收集器：老年代；标记-清楚算法（Mark-Sweep）；多线程；GC区域名称(GCLogging)：ParOldGen；优点：响应速度快、停顿时间短。；缺点：1.对CPU资源敏感；2.无法处理浮动垃圾，因为GC标记和用户线程并发运行着；3.空间碎片多<br>G1：新生代，老年代；标记-整理，复制；多线程；优点：并行与并发，分代收集，空间整合，可预测的停顿</p>
<h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs]100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure>
<p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p>
<p>GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“[Full GC（System）”。</p>
<p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的</p>
<p>后面方括号内部的“3324K-&gt;152K（3712K）”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-&gt;152K（11904K）”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。</p>
<p>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致</p>
<h3 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UseSerialGC</td>
<td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParNewGC</td>
<td>打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseConcMarkSweepGC</td>
<td>打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后壁收集器使用</td>
</tr>
<tr>
<td>UseParallelGC</td>
<td>虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS MarkSweep）的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParallelOldGC</td>
<td>打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1</td>
</tr>
<tr>
<td>PretenureSizeThreshold</td>
<td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄加1，当超过这个参数值时就进入老年代</td>
</tr>
<tr>
<td>UseAdaptiveSizePolicy</td>
</tr>
</tbody>
</table>
<p>动态调整Java堆中各个区域的大小以及进入老年代的年龄</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HandlePromotionFailure</td>
<td>是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td>
</tr>
</tbody>
</table>
<p>ParallelGCThreads | 设置并行GC时进行内存回收的线程数<br>GCTimeRatio | GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效<br>MaxGCPauseMillis | 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效<br>CMSinitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%，仅在使用CMS收集器时生效<br>UseCMSCompactAtFullCollection | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效<br>CMSFullGCsBeforeCompaction | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</p>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p>对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中。</p>
<h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<p>请看下面例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@VM</span> param -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEdenAllocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] alloc1, alloc2, alloc3, alloc4;</span><br><span class="line"></span><br><span class="line">        alloc1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看vm的参数：</p>
<ul>
<li>-XX:+UseSerialGC： 保证使用Serial/SerialOld收集器作为例子</li>
<li>-Xms20M -Xmx20M -Xmn10M： 限制堆为20M，10M新生代10M老年代</li>
<li>-XX:SurvivorRatio=8： 新生代Eden区与一个Survivor区比例8:1</li>
<li>-XX:+PrintGCDetails： 收集器日志参数</li>
</ul>
<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC[DefNew: <span class="number">6817</span>K-&gt;<span class="number">484</span>K(<span class="number">9216</span>K), <span class="number">0.0038248</span> secs] <span class="number">6817</span>K-&gt;<span class="number">6628</span>K(<span class="number">19456</span>K), <span class="number">0.0038598</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">Heap</span><br><span class="line">def <span class="keyword">new</span> generation total <span class="number">9216</span>K, used <span class="number">5072</span>K [<span class="number">0x00000000f9a00000</span>, <span class="number">0x00000000fa400000</span>, <span class="number">0x00000000fa400000</span>)</span><br><span class="line">eden space <span class="number">8192</span>K, <span class="number">56</span>% used [<span class="number">0x00000000f9a00000</span>, <span class="number">0x00000000f9e7af60</span>, <span class="number">0x00000000fa200000</span>)</span><br><span class="line">from space <span class="number">1024</span>K, <span class="number">47</span>% used [<span class="number">0x00000000fa300000</span>, <span class="number">0x00000000fa379110</span>, <span class="number">0x00000000fa400000</span>)</span><br><span class="line">to space <span class="number">1024</span>K, <span class="number">0</span>% used [<span class="number">0x00000000fa200000</span>, <span class="number">0x00000000fa200000</span>, <span class="number">0x00000000fa300000</span>)</span><br><span class="line">tenured generation total <span class="number">10240</span>K, used <span class="number">6144</span>K [<span class="number">0x00000000fa400000</span>, <span class="number">0x00000000fae00000</span>, <span class="number">0x00000000fae00000</span>)</span><br><span class="line">the space <span class="number">10240</span>K, <span class="number">60</span>% used [<span class="number">0x00000000fa400000</span>, <span class="number">0x00000000faa00030</span>, <span class="number">0x00000000faa00200</span>, <span class="number">0x00000000fae00000</span>)</span><br><span class="line">compacting perm gen total <span class="number">21248</span>K, used <span class="number">2519</span>K [<span class="number">0x00000000fae00000</span>, <span class="number">0x00000000fc2c0000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">the space <span class="number">21248</span>K, <span class="number">11</span>% used [<span class="number">0x00000000fae00000</span>, <span class="number">0x00000000fb075e08</span>, <span class="number">0x00000000fb076000</span>, <span class="number">0x00000000fc2c0000</span>)</span><br><span class="line">No shared spaces configured.</span><br></pre></td></tr></table></figure>
<p>分析如下：</p>
<p>分配alloc4时发生一次minorGC，Eden区从6817K减少到484K。由于alloc1、alloc2、alloc3都是存活的所以没有对象可收。<br>这次GC发生的原因是给allo-cation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。<br>GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。<br>这次GC结束后，4MB的allocation4对象顺利分配在Eden中，因此程序执行完的结果是Eden占用4MB（被allocation4占用），Survivor空闲，老年代被占用6MB（被allocation1、allocation2、allocation3占用）</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Sur-vivor区之间发生大量的内存复制。注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p>
<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</p>
<p>在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/">Java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Guice依赖注入" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/01/01/Guice依赖注入/" class="article-date">
  	<time datetime="2015-12-31T23:00:00.000Z" itemprop="datePublished">2016-01-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/01/Guice依赖注入/">Guice依赖注入</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Guice是google的依赖注入框架，它能够帮助我们自动的实现应用的依赖注入的过程。在本篇中我们继续上一篇的例子来学习如何通过Guice来完成依赖注入。</p>
<h2 id="使用maven创建project"><a href="#使用maven创建project" class="headerlink" title="使用maven创建project"></a>使用maven创建project</h2><ol>
<li><p>使用命令行来创建一个project(将命令行中的mycompany.app和my-app替换为你自己组织和项目的名字):</p>
<p> <code>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false</code></p>
</li>
<li><p>将创建的project导入Eclipse</p>
</li>
<li><p>增加maven dependency在pom.xml中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guice&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我的project的目录结构如下：</p>
<h3 id="Service-classes"><a href="#Service-classes" class="headerlink" title="Service classes:"></a>Service classes:</h3><p>MessageService.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simonwoo.injector.services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EmailServiceImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simonwoo.injector.services.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.inject.Singleton;</span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.services.MessageService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Email sent to "</span> + receiver + <span class="string">" with Message= "</span> + msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SMSServiceImpl.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simonwoo.injector.services.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.inject.Singleton;</span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.services.MessageService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSEmailServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"SMS sent to "</span> + receiver + <span class="string">" with Message= "</span> + msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在<code>EmailServiceImpl</code>和<code>SMSServiceImpl</code>含有@Singleton标签。由于所有的Service是通过Injector创建，这个标签是用来告诉injector这两个Service是单例。</p>
<h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p>MyApplication.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simonwoo.injector.application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.inject.Inject;</span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.services.MessageService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyApplication</span><span class="params">(MessageService messageService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Inject</span></span><br><span class="line">    <span class="comment">// public void setMessageService(MessageService messageService) &#123;</span></span><br><span class="line">    <span class="comment">// this.messageService = messageService;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// here are some logic to manipulate msg</span></span><br><span class="line">        <span class="keyword">return</span> messageService.sendMessage(msg, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Guice同时支持setter和构造器的方式进行依赖注入。但是在该应用中，我推荐使用构造器的方式，因为MyApplication在没有Service的情况下无法运行下去。</p>
<h3 id="实现注入"><a href="#实现注入" class="headerlink" title="实现注入"></a>实现注入</h3><p>Guice不知道哪个Service将会被注入，所以我们需要扩展<code>AbstractModule</code>并实现configure方法来告诉如果进行注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simonwoo.injector.appInjector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.inject.AbstractModule;</span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.services.MessageService;</span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.services.impl.EmailServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppInjector</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// bind service to implementation class</span></span><br><span class="line">        bind(MessageService.class).to(EmailServiceImpl.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该例子中，我们将<code>EmailService</code>绑定为<code>MessageService</code>的实现。</p>
<h3 id="Client-Code"><a href="#Client-Code" class="headerlink" title="Client Code"></a>Client Code</h3><p>APP.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simonwoo.injector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.inject.Guice;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.Injector;</span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.appInjector.AppInjector;</span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.application.MyApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Client clalss</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        Injector injector = Guice.createInjector(<span class="keyword">new</span> AppInjector());</span><br><span class="line">        MyApplication app = injector.getInstance(MyApplication.class);</span><br><span class="line"></span><br><span class="line">        app.sendMessage(<span class="string">"hello"</span>, <span class="string">"zhang san"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们创通过<code>Guice.createInjector(new AppInjector());</code>建一个Injector, 然后我们使用该Injector来初始化我们的Application。</p>
<h3 id="Junit-test"><a href="#Junit-test" class="headerlink" title="Junit test"></a>Junit test</h3><p>由于我们只是想测试<code>MyApplication</code>，所以我们没有必要创建真实地Service。我们可以增加一个简单的Mock service实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simonwoo.injector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.services.MessageService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockMessageServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.simonwoo.injector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.inject.AbstractModule;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.Guice;</span><br><span class="line"><span class="keyword">import</span> com.google.inject.Injector;</span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.application.MyApplication;</span><br><span class="line"><span class="keyword">import</span> com.simonwoo.injector.services.MessageService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Unit test for simple App.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Injector injector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @BeforeClass</span></span><br><span class="line">    <span class="comment">// // executed only once before all tests</span></span><br><span class="line">    <span class="comment">// public void setUp() &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="comment">// executed before each test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        injector = Guice.createInjector(<span class="keyword">new</span> AbstractModule() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                bind(MessageService.class).to(MockMessageServiceImpl.class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyApplication app = injector.getInstance(MyApplication.class);</span><br><span class="line">        Assert.assertTrue(app.sendMessage(<span class="string">"hello"</span>, <span class="string">"zhang san"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的代码放在了<a href="https://github.com/simonwoo/guice_example" target="_blank" rel="external">github</a>上。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/DI/">DI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Guice/">Guice</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/">Java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-依赖注入Dependency Injection(DI)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/01/01/依赖注入Dependency Injection(DI)/" class="article-date">
  	<time datetime="2015-12-31T23:00:00.000Z" itemprop="datePublished">2016-01-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/01/01/依赖注入Dependency Injection(DI)/">依赖注入Dependency Injection(DI)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>依赖注入设计模式允许我们消除硬编码依赖，它能使我们的应用松耦合，易于扩展和维护。依赖注入可使依赖解决从编译器（compile-time）到运行期（runtime）。</p>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><p>假设我们有一个应用使用<code>EmailService</code>发送邮件，代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailService</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">sendEmail</span><span class="params">(String msg, String receiver)</span></span>&#123;</span><br><span class="line">		<span class="comment">// logic to send email</span></span><br><span class="line">		System.out.println(<span class="string">"Email send to "</span> + receiver + <span class="string">" with message="</span> + msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EmailService</code>中包含一个方法用于发送邮件。我们的应用将会使用<code>EmailService</code>来发送邮件, 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> EmailService emailService = <span class="keyword">new</span> EmailService();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span></span>&#123;</span><br><span class="line">		<span class="comment">//here are some logic to process message</span></span><br><span class="line">		emailService.sendEmail(msg, receiver);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户会使用<code>Application</code>完成发送消息的过程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Application myApplication = <span class="keyword">new</span> Application();</span><br><span class="line">		<span class="comment">// send an email with body hello, recevier zhang san</span></span><br><span class="line">		myApplication.sendMessage(<span class="string">"hello"</span>, <span class="string">"zhang san"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码实现了发送邮件的过程。代码运行良好，似乎没有什么问题。但是仔细分析之后，我们会发现代码有一些限制：</p>
<ul>
<li>在<code>Application</code>中我们直接初始化<code>EmailService</code>, 这直接导致硬编码依赖（hard-code dependency）。如果将来我们想使用其他的<code>EmailService</code>，我们将不得不直接改变<code>Application</code>的代码。这导致我们的应用难以扩展，更糟糕的是，如果<code>EmailService</code>在多个地方使用的话，我们将不得不每个地方都进行更改。</li>
<li>测试会变得非常困难。因为<code>Application</code>直接使用真实地<code>EmailService</code>实例,这将导致我们无法在我们的测试中使用Mock类。</li>
<li>将来如果我们想使用其他发送消息的方式，如：SMS, Facebook Message等，我们将不得不增加新的<code>Application</code>。这会导致<code>Application</code>和客户端代码改变。</li>
</ul>
<h2 id="依赖注入实现"><a href="#依赖注入实现" class="headerlink" title="依赖注入实现"></a>依赖注入实现</h2><p>使用依赖注入Injection Dependency(DI)设计模式，可以解决以上问题。</p>
<ul>
<li>Service应被设计为Interface或者base class</li>
<li>Application应根据Service接口进行设计</li>
<li>注入器完成Service和Application的初始化工作</li>
</ul>
<p>首先我们定义一个Service接口<code>MessageService</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageService</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们有两种实现方式：SMS和Email:</p>
<p><code>EmailServiceImapl</code>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Email sent to "</span>+ receiver + <span class="string">" with Message="</span>+msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SMSServiceImapl</code>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"SMS sent to "</span>+ receiver + <span class="string">" with Message="</span>+msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service部分完成，下面我们实现Application部分。首先我们定义一个接口（不是必须）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义一个实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">implements</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyApplication</span><span class="params">(MessageService messageService)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.messageService = messageService;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span></span>&#123;</span><br><span class="line">		<span class="comment">// here are some logic to manipulate msg</span></span><br><span class="line">		messageService.sendMessage(msg, receiver);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的实现中，我们的应用只是使用<code>MessageService</code>, 它并不对其进行初始化。这很好的实现了分离。这也使我们的测试更加容易。现在我们只剩下最后一步，实现一个注入器，完成<code>MessageService</code>的初始化并将其注入到<code>MyApplication</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectorImpl</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">getApplication</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(name.toLowerCase().equals(<span class="string">"email"</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MyApplication(<span class="keyword">new</span> EmailServiceImpl());</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(name.toLowerCase().equals(<span class="string">"sms"</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> MyApplication(<span class="keyword">new</span> SMSServiceImpl());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种简单的使用构造函数实现依赖注入的方式，它会根据服务的名字来返回Application实例。客户代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">// send an email</span></span><br><span class="line">		Application myApplication = InjectorImpl.getApplication(<span class="string">"Email"</span>);</span><br><span class="line">		myApplication.sendMessage(<span class="string">"hello"</span>, <span class="string">"zhang san"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种实现依赖注入的方式是使用setter方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">implements</span> <span class="title">Application</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyApplication</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">setMessageService</span><span class="params">(MessageService messageService)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.messageService = messageService;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String msg, String receiver)</span></span>&#123;</span><br><span class="line">		<span class="comment">// here are some logic to manipulate msg</span></span><br><span class="line">		messageService.sendMessage(msg, receiver);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectorImpl</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">getApplication</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">	Application application = <span class="keyword">new</span> MyApplication();</span><br><span class="line">		<span class="keyword">if</span>(name.toLowerCase().equals(<span class="string">"email"</span>))&#123;</span><br><span class="line">			application.setMessageService(<span class="keyword">new</span> EmailServiceImpl());</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(name.toLowerCase().equals(<span class="string">"sms"</span>))&#123;</span><br><span class="line">			application.setMessageService(<span class="keyword">new</span> SMSServiceImpl());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> application;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们既可以通过构造函数来实现依赖注入，又可以通过setter方式实现。具体采用哪种方式根据你的具体需求。当你的应用必须需要一个service才能运行的情况下，则采用构造函数的方式。</p>
<h2 id="DI库"><a href="#DI库" class="headerlink" title="DI库"></a>DI库</h2><p>Spring, Guice, J2EE CDI是通过反射和java annotation的方式来实现依赖注入的库。它使依赖注入更加容易实现，我们只需要简单的配置便可以实现。在下一篇中我将会对Guice实现做出说明。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/DI/">DI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Java/">Java</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 吴冲
    	</div>
    </div>
  </div>
</footer>

    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
    root: /blog/
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>